import * as PIXI            from 'pixi.js'
import * as PIXIP           from 'pixi-projection'
import React, { Component } from 'react'


import Line                 from '2d/line/web/Line'
import Point                from '2d/point/web/Point'
import Context              from '2d/stage/all/Context'
import createDebugger       from 'core/debug/api/create'


const debug = createDebugger(`2d:lineTool:web:lineTool`)

class LineTool extends Component {
  constructor() {
    super()

    this.state = {
      x: 0,
      y: 0,
      path: [],
      isOver: false,
    }
  }

  componentDidMount() {
    this.mount()
  }

  componentWillUnmount() {
    this.unmount()
  }

  process = () => {
    const { context } = this.props

    const {
      x,
      y,
    } = context.app.renderer.plugins.interaction.mouse.global

    if (this.state.x !== x || this.state.y !== y) {
      this.setState({ x, y })
    }
  }

  mount = (payload) => {
    const { context } = this.props

    context.app.ticker.add(this.process)
    context.app.renderer.plugins.interaction.on('mousedown', this.onGlobalClick)
  }

  unmount = () => {
    const { context } = this.props

    context.app.ticker && context.app.ticker.remove(this.process)
    context.app.renderer.plugins.interaction.off('mousedown', this.onGlobalClick)
  }

  pointInsideCircle = ({
    center,
    radius,
    point,
  }) => {
    const [x, y] = point
    const [xc, yc] = center
    return ((x - xc) * (x - xc) + (y - yc) * (y - yc)) < Math.pow(radius, 2)
  }

  onGlobalClick = (payload) => {
    const { onFinish } = this.props
    const { path } = this.state

    const {
      data: {
        global: {
          x, y,
        }
      }
    } = payload

    if (
      path.length
      && this.pointInsideCircle({
        center: path[0],
        radius: 16,
        point: [x, y],
      })
    ) {
      return onFinish && onFinish({ path })
    }

    this.setState(({ path }) => ({
      path: [
        ...path,
        [x, y]
      ]
    }))
  }

  onOver = ({ index }) => {
    index === 0 && this.setState({ isOver: true })
  }

  onOut = ({ index }) => {
    index === 0 && this.setState({ isOver: false })
  }

  renderPoint = ({ coordList, index }) => {
    const { isOver } = this.state

    return (
      <Point
        key={`point_${ index }`}
        x={ coordList[0] }
        y={ coordList[1] }

        color={ isOver && index === 0 && 0xff0000 }

        onOver={ () => this.onOver({ index }) }
        onOut={ () => this.onOut({ index }) }
      />
    )
  }

  render() {
    debug(`render()`)

    const { x, y, path } = this.state

    return (
      <React.Fragment>
        {path.length && (
          <Line path={[...path.slice(-1), [x, y]]} />
        )}
        <Point
          x={ x }
          y={ y }
        />
        {path.map((coordList, index) => this.renderPoint({ coordList, index }))}
        <Line path={ path } />
      </React.Fragment>
    )
  }
}

export default (props) => {
  return (
    <Context.Consumer>
      {(context) => (
        <LineTool {...props} context={ context } />
      )}
    </Context.Consumer>
  )
}
