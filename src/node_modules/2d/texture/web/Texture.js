import * as PIXI            from 'pixi.js'
import * as PIXIP           from 'pixi-projection'
import React, { Component } from 'react'


import Context              from '2d/stage/all/Context'
import Line                 from '2d/line/web/Line'


const WIDTH = 500
const HEIGHT = 300

const textureLoad = ({ imageLink }) => new Promise((resolve, reject) => {
  if (PIXI.TextureCache[imageLink]) {
    resolve()
  }

  PIXI.loader
    .add(imageLink, imageLink)
    .load(() => resolve())
})

const processKB = ({
  x1, y1,
  x2, y2,
}) => {
  const k = - (y1 - y2) / (x2 - x1)
  const b = - (x1 * y2 - x2 * y1) / (x2 - x1)

  return { k, b }
}

const processPointOnLength = ({
  pointFrom,
  pointTo,
  length: R,
}) => {
  const [x1, y1] = pointFrom
  const [x2, y2] = pointTo

  const { k, b } = processKB({ x1, y1, x2, y2 })

  let x
  let y

  if (k !== Infinity) {
    x = (x1 < x2 ? 1 : -1) * Math.sqrt((R * R) / (1 + k * k)) + x1
    y = k * x + b
  } else {
    x = x1
    y = y1 + R
  }

  return [x, y]
}

const distance = (point0, point1) => {
  const delta0 = point1[0] - point0[0]
  const delta1 = point1[1] - point0[1]
  return Math.sqrt(delta0 * delta0 + delta1 * delta1)
}

const processOuterBox = ({ path }) => {
  const corner1 = [...path[0]]
  const corner2 = [...path[0]]

  let first = false

  for (let coord of path) {
    if (first) {
      first = true
      continue
    }

    if (corner1[0] > coord[0]) {
      corner1[0] = coord[0]
    }
    if (corner1[1] > coord[1]) {
      corner1[1] = coord[1]
    }
    if (corner2[0] < coord[0]) {
      corner2[0] = coord[0]
    }
    if (corner2[1] < coord[1]) {
      corner2[1] = coord[1]
    }
  }

  const [x1, y1] = corner1
  const [x2, y2] = corner2

  return [
    [x1, y1],
    [x2, y1],
    [x2, y2],
    [x1, y2],
  ]
}

const transformPerspective = ({
  perspectivePath: path,
}) => {
  const length0 = distance(path[0], path[1])
  const length1 = distance(path[1], path[2])
  const length2 = distance(path[2], path[3])
  const length3 = distance(path[3], path[0])

  const corner1 = path[0]

  //const length = 

  // console.log(`length0`, length0)
  // console.log(`length1`, length1)
  // console.log(`length2`, length2)
  // console.log(`length3`, length3)
  // console.log(`length`, length)

  const corner2 = processPointOnLength({
    pointFrom: path[0],
    pointTo: path[1],
    length: (length0 >= length2) ? WIDTH : (WIDTH * (length0 / length2)),
  })

  const corner4 = processPointOnLength({
    pointFrom: path[0],
    pointTo: path[3],
    length: (length3 >= length1) ? HEIGHT : (HEIGHT * (length3/ length1))
  })

  const offsetX = corner4[0] - path[3][0]
  const offsetY = corner4[1] - path[3][1]

  const point2 = [
    path[2][0] + offsetX,
    path[2][1] + offsetY,
  ]

  const corner3 = processPointOnLength({
    pointFrom: corner4,
    pointTo: point2,
    length: (length2 >= length0) ? WIDTH : (WIDTH * (length2 / length0)),
  })

  const next = [
    corner1,
    corner2,
    corner3,
    corner4,
  ]

  return next
}

const pathScale = ({ path }) => {
  const length0 = distance(path[0], path[1])
  const length1 = distance(path[1], path[2])
  const length2 = distance(path[2], path[3])
  const length3 = distance(path[3], path[0])

  const size = 400

  const corner1 = processPointOnLength({
    pointFrom: path[0],
    pointTo: path[1],
    length: size,
  })

  const corner2 = processPointOnLength({
    pointFrom: path[3],
    pointTo: path[2],
    length: size,
  })

  const corner0 = processPointOnLength({
    pointFrom: path[3],
    pointTo: path[0],
    length: size,
  })

  const corner11 = processPointOnLength({
    pointFrom: corner2,
    pointTo: corner1,
    length: size,
  })

  const corner3 = processPointOnLength({
    pointFrom: corner0,
    pointTo: path[3],
    length: size * 2,
  })

  const corner21 = processPointOnLength({
    pointFrom: corner11,
    pointTo: corner2,
    length: size * 2,
  })

  return [
    corner0,
    corner11,
    corner21,
    corner3,
  ]
}

class Texture extends Component {  
  componentDidMount = async () => {
    const { context } = this.props
    const { stage } = context.app

    this.stage = stage

    const { imageLink } = this.props

    await textureLoad({ imageLink })

    this.mount()
  }

  componentDidUpdate = async (prevProps) => {
    const { imageLink } = this.props

    if (imageLink !== prevProps.imageLink) {
      await textureLoad({ imageLink })

      this.textureBase = PIXI.TextureCache[imageLink]
      this.sprite.texture = this.textureBase
    }

    this.update(this.props)
  }

  componentWillUnmount() {
    this.unmount()
  }

  mount = () => {
    this.instance = new PIXI.Container()
    this.main = new PIXI.Container()

    this.init(this.props)
    this.update(this.props)

    this.stage.addChild(this.instance)
    this.instance.addChild(this.main)
  }

  unmount = () => {
    this.stage.removeChild(this.instance)
  }

  init = (props) => {
    const { context } = props
    const { renderer } = context.app

    renderer.state.blendModes[20] = [0, WebGLRenderingContext.ONE_MINUS_SRC_ALPHA]

    const { imageLink, path, perspectivePath } = props

    const main = this.main

    // const outerBox = processOuterBox({ path })

    // const length0 = distance(outerBox[0], outerBox[1])
    // const length1 = distance(outerBox[1], outerBox[2])
    // const length2 = distance(outerBox[2], outerBox[3])
    // const length3 = distance(outerBox[3], outerBox[0])

    // const width = length0 > length2 ? length0 : length2
    // const height = length1 > length3 ? length1 : length3

    const length0 = distance(perspectivePath[0], perspectivePath[1])
    const length1 = distance(perspectivePath[1], perspectivePath[2])
    const length2 = distance(perspectivePath[2], perspectivePath[3])
    const length3 = distance(perspectivePath[3], perspectivePath[0])

    const width = length0 > length2 ? length0 : length2
    const height = length1 > length3 ? length1 : length3    

    this.textureBase = PIXI.TextureCache[imageLink]
    this.spriteBase = new PIXI.extras.TilingSprite(this.textureBase, width, height)
    this.containerTexture = new PIXI.Container()
    this.containerTexture.addChild(this.spriteBase)   
    
    this.texture = new PIXI.RenderTexture(
      new PIXI.BaseRenderTexture(width, height, PIXI.SCALE_MODES.LINEAR, 1)
    )

    renderer.render(this.containerTexture, this.texture)

    //texture.baseTexture.mipmap = true
    //texture.baseTexture.scaleMode = PIXI.SCALE_MODES.NEAREST
    //texture.baseTexture.sourceScale = 10

    //console.log(`TEXTURE`, texture)

    this.line = new PIXI.Graphics()
    this.instance.addChild(this.line)

    this.sprite = new PIXI.projection.TilingSprite2d(this.textureBase, 5000, 5000)
    this.sprite.anchor.set(0.5, 0.5)
    //this.sprite = new PIXI.projection.Sprite2d(this.texture)

    main.addChild(this.sprite)
    
    main.filters = [new PIXI.filters.AlphaFilter()]

    this.mask = new PIXI.Graphics()
    this.foreground = new PIXI.Graphics()
    this.foreground.blendMode = 20
    
    main.addChild(this.mask)
    main.addChild(this.foreground)

    main.mask = this.mask


    //this.instance.interactive = true
  }

  updateMask = (props) => {
    const { path = [] } = props
    const { pathListForeground = [] } = props

    const mask = this.mask
    const foreground = this.foreground

    mask.clear()

    mask.beginFill(0xffffff)

    mask.moveTo(path[0][0], path[0][1])
    
    for (let index = 1; index < path.length; index++) {
      const [x, y] = path[index]
      mask.lineTo(x, y)
    }

    if (pathListForeground) {
      foreground.clear()
      foreground.beginFill(0x000000, 1)

      for (let pathForeground of pathListForeground) {
        foreground.moveTo(pathForeground[0][0], pathForeground[0][1])

        for (let index = 1; index < pathForeground.length; index++) {
          const [x, y] = pathForeground[index]
          foreground.lineTo(x, y)
        }
      }

      foreground.endFill()
    }
    // foreground.clear()
    // foreground.beginFill(0x000000, 1)
    // foreground.drawCircle(175, 200, 20)
    // foreground.drawCircle(225, 200, 20)
    // foreground.endFill()
  }

  updatePerspective = (props) => {
    const { scale = 1 } = this.props
    const { renderer } = this.props.context.app


    const { 
      path,
      perspectivePath,
    } = props

    const perspective = pathScale({
      path: perspectivePath,
    })

    // const outerBox = processOuterBox({ path })

    // //console.log(`outerBox`, outerBox)

    const length0 = distance(perspectivePath[0], perspectivePath[1])
    const length1 = distance(perspectivePath[1], perspectivePath[2])
    const length2 = distance(perspectivePath[2], perspectivePath[3])
    const length3 = distance(perspectivePath[3], perspectivePath[0])

    console.log(`length0`, length0)
    console.log(`length1`, length1)
    console.log(`length2`, length2)
    console.log(`length3`, length3)

    const width = length0 > length2 ? length0 : length2
    const height = length1 > length3 ? length1 : length3    

    this.spriteBase.width = width
    this.spriteBase.height = height

    this.sprite.tileScale.x = scale
    this.sprite.tileScale.y = scale

    renderer.render(this.containerTexture, this.texture)

    // const perspective = transformPerspective({
    //   perspectivePath,
    // })

    const next = perspectivePath

    const quad = [
      new PIXI.Point(next[0][0], next[0][1]),
      new PIXI.Point(next[1][0], next[1][1]),
      new PIXI.Point(next[2][0], next[2][1]),
      new PIXI.Point(next[3][0], next[3][1]),
    ]

    this.sprite.proj.mapSprite(this.sprite, quad)

    // const line = this.line

    // line.clear()
    // line.lineStyle(2, 0x00eeff, 1)
    // line.moveTo(perspective[0][0], perspective[0][1])
    // for (let index = 1; index < perspective.length; index++) {
    //   const [x, y] = perspective[index]
    //   line.lineTo(x, y)
    // }    
  }

  update = (props) => {
    const { scale = 1 } = props

    this.updateMask(props)
    this.updatePerspective(props)
  }

  render() {
    return null
  }
}

export default (props) => {
  return (
    <Context.Consumer>
      {(context) => (
        <Texture {...props} context={ context } />
      )}
    </Context.Consumer>
  )
}