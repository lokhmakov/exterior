import * as PIXI from 'pixi.js'
import * as PIXIP from 'pixi-projection'
import React, { Component } from 'react'


import Context from '2d/stage/all/Context'
import Line from '2d/line/web/Line'


const textureLoad = ({ imageLink }) => new Promise((resolve, reject) => {
  if (PIXI.TextureCache[imageLink]) {
    resolve()
  }

  PIXI.loader
    .add(imageLink, imageLink)
    .load(() => resolve())
})

const processKB = ({
  x1, y1,
  x2, y2,
}) => {
  const k = - (y1 - y2) / (x2 - x1)
  const b = - (x1 * y2 - x2 * y1) / (x2 - x1)

  return { k, b }
}

const processPointOnLength = ({
  pointFrom,
  pointTo,
  length: R,
}) => {
  const [x1, y1] = pointFrom
  const [x2, y2] = pointTo

  const { k, b } = processKB({ x1, y1, x2, y2 })

  let x
  let y

  if (k !== Infinity) {
    x = (x1 < x2 ? 1 : -1) * Math.sqrt((R * R) / (1 + k * k)) + x1
    y = k * x + b
  } else {
    x = x1
    y = y1 + R
  }

  return [x, y]
}

class Texture extends Component {
  componentDidMount = async () => {
    const { context } = this.props
    const { stage } = context.app

    this.stage = stage

    const { imageLink } = this.props

    await textureLoad({ imageLink })

    this.mount()
  }

  componentDidUpdate = async (prevProps) => {
    const { imageLink } = this.props

    if (imageLink !== prevProps.imageLink) {
      await textureLoad({ imageLink })

      const texture = PIXI.TextureCache[imageLink]

      this.sprite.texture = texture
    }

    this.update(this.props)
  }

  componentWillUnmount() {
    this.unmount()
  }

  mount = () => {
    this.instance = new PIXI.Container()
    this.main = new PIXI.Container()

    this.init(this.props)
    this.update(this.props)

    this.stage.addChild(this.instance)
    this.instance.addChild(this.main)
  }

  unmount = () => {
    this.stage.removeChild(this.instance)
  }

  init = (props) => {
    const { context } = props
    const { renderer } = context.app

    renderer.state.blendModes[20] = [0, WebGLRenderingContext.ONE_MINUS_SRC_ALPHA]

    const { screen } = renderer
    const { width, height } = screen

    const { imageLink } = props
    const { x, y } = props
    const main = this.main

    const texture = PIXI.TextureCache[imageLink]

    texture.baseTexture.mipmap = true
    // texture.baseTexture.scaleMode = PIXI.SCALE_MODES.NEAREST
    // texture.baseTexture.sourceScale = 10

    // console.log(`TEXTURE`, texture)

    this.line = new PIXI.Graphics()
    this.instance.addChild(this.line)


    this.sprite = new PIXI.projection.TilingSprite2d(texture, 100000, 100000)

    main.addChild(this.sprite)

    main.filters = [new PIXI.filters.AlphaFilter()]

    this.mask = new PIXI.Graphics()
    this.foreground = new PIXI.Graphics()
    this.foreground.blendMode = 20

    main.addChild(this.mask)
    main.addChild(this.foreground)

    main.mask = this.mask


    //this.instance.interactive = true
  }

  updateMask = (props) => {
    const { path = [] } = props
    const { pathListForeground = [] } = props

    const mask = this.mask
    const foreground = this.foreground

    mask.clear()

    mask.beginFill(0xffffff)

    mask.moveTo(path[0][0], path[0][1])

    for (let index = 1; index < path.length; index++) {
      const [x, y] = path[index]
      mask.lineTo(x, y)
    }

    if (pathListForeground) {
      foreground.clear()
      foreground.beginFill(0x000000, 1)

      for (let pathForeground of pathListForeground) {
        foreground.moveTo(pathForeground[0][0], pathForeground[0][1])

        for (let index = 1; index < pathForeground.length; index++) {
          const [x, y] = pathForeground[index]
          foreground.lineTo(x, y)
        }
      }

      foreground.endFill()
    }
    // foreground.clear()
    // foreground.beginFill(0x000000, 1)
    // foreground.drawCircle(175, 200, 20)
    // foreground.drawCircle(225, 200, 20)
    // foreground.endFill()
  }

  updatePerspective = (props) => {
    const { scale = 1 } = this.props

    //const w = 200
    //const h = 100
    const w = this.sprite.texture.orig.width * scale
    const h = this.sprite.texture.orig.height * scale

    const {
      perspectivePath: path,
    } = props

    const corner1 = path[0]

    const corner2 = processPointOnLength({
      pointFrom: path[0],
      pointTo: path[1],
      length: w,
    })

    const corner4 = processPointOnLength({
      pointFrom: path[0],
      pointTo: path[3],
      length: h,
    })

    const pointOffset = [
      path[2][0] + corner4[0] - path[3][0],
      path[2][1] + corner4[1] - path[3][1],
    ]

    const distance = (point0, point1) => {
      const delta0 = point1[0] - point0[0]
      const delta1 = point1[1] - point0[1]
      return Math.sqrt(delta0 * delta0 + delta1 * delta1)
    }

    const lengthTop = distance(path[0], path[1])
    const lengthBottom = distance(path[3], path[2])

    const k = lengthBottom / lengthTop

    //console.log(`K`, k)

    //console.log(`path[0]`, path[0])
    //console.log(`path[1]`, path[1])
    //console.log(`lengthTop`, lengthTop)
    //console.log(`lengthBottom`, lengthBottom)

    const corner3 = processPointOnLength({
      pointFrom: corner4,
      pointTo: pointOffset,
      length: w * k,
    })

    const next = [
      corner1,
      corner2,
      corner3,
      corner4,
    ]

    //console.log(`NEXT`, next)

    const quad = [
      new PIXI.Point(next[0][0], next[0][1]),
      new PIXI.Point(next[1][0], next[1][1]),
      new PIXI.Point(next[2][0], next[2][1]),
      new PIXI.Point(next[3][0], next[3][1]),
    ]

    this.sprite.tileProj.mapSprite(this.sprite, quad)

    const line = this.line

    line.clear()
    line.lineStyle(2, 0x00eeff, 1)
    line.moveTo(next[0][0], next[0][1])

    for (let index = 1; index < next.length; index++) {
      const [x, y] = next[index]
      line.lineTo(x, y)
    }
    //this.sprite.tileProj.mapBilinearSprite(this.sprite, quad)


    // this.sprite.scale.x = scale
    // this.sprite.scale.y = scale
  }

  update = (props) => {
    const { scale = 1 } = props

    this.updateMask(props)
    this.updatePerspective(props)
  }

  render() {
    return null
  }
}

export default (props) => {
  return (
    <Context.Consumer>
      {(context) => (
        <Texture {...props} context={context} />
      )}
    </Context.Consumer>
  )
}