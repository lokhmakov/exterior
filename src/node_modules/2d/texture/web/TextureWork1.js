import * as PIXI            from 'pixi.js'
import * as PIXIP           from 'pixi-projection'
import React, { Component } from 'react'


import Context              from '2d/stage/all/Context'


const textureLoad = ({ imageLink }) => new Promise((resolve, reject) => {
  if (PIXI.TextureCache[imageLink]) {
    resolve()
  }

  PIXI.loader
    .add(imageLink, imageLink)
    .load(() => resolve())
})

const processKB = ({
  x1, y1,
  x2, y2,
}) => {
  const k = - (y1 - y2) / (x2 - x1)
  const b = - (x1 * y2 - x2 * y1) / (x2 - x1)

  return { k, b }
}

const processPointOnLength = ({
  pointFrom,
  pointTo,
  length: R,
}) => {
  const [x1, y1] = pointFrom
  const [x2, y2] = pointTo

  const { k, b } = processKB({ x1, y1, x2, y2 })

  let x
  let y

  if (k !== Infinity) {
    x = (x1 < x2 ? 1 : -1) * Math.sqrt((R * R) / (1 + k * k)) + x1
    y = k * x + b
  } else {
    x = x1
    y = y1 + R
  }

  return [x, y]
}

class Texture extends Component {  
  componentDidMount = async () => {
    const { context } = this.props
    const { stage } = context.app

    this.stage = stage

    const { imageLink } = this.props

    await textureLoad({ imageLink })

    this.mount()
  }

  componentDidUpdate = async (prevProps) => {
    const { imageLink } = this.props

    if (imageLink !== prevProps.imageLink) {
      await textureLoad({ imageLink })

      const texture = PIXI.TextureCache[imageLink]

      this.sprite.texture = texture
    }

    this.update(this.props)
  }

  componentWillUnmount() {
    this.unmount()
  }

  mount = () => {
    this.instance = new PIXI.Container()

    this.init(this.props)
    this.update(this.props)

    this.stage.addChild(this.instance)
  }

  unmount = () => {
    this.stage.removeChild(this.instance)
  }

  init = (props) => {
    const { context } = props
    const { renderer } = context.app

    const { screen } = renderer
    const { width, height } = screen

    const { imageLink } = props
    const { x, y } = props
    const instance = this.instance

    const texture = PIXI.TextureCache[imageLink]

    texture.baseTexture.mipmap = true
    // texture.baseTexture.scaleMode = PIXI.SCALE_MODES.NEAREST
    // texture.baseTexture.sourceScale = 10

    // console.log(`TEXTURE`, texture)

    this.sprite = new PIXI.projection.TilingSprite2d(texture, 100000, 100000)

    instance.addChild(this.sprite)
    
    //this.instance.interactive = true
  }

  updateMask = (props) => {
    const { path = [] } = props
    
    const mask = new PIXI.Graphics()

    mask.clear()

    mask.beginFill(0xffffff)

    mask.moveTo(path[0][0], path[0][1])
    
    for (let index = 1; index < path.length; index++) {
      const [x, y] = path[index]
      mask.lineTo(x, y)
    }    

    this.instance.mask = mask
  }

  updatePerspective = (props) => {
    const { scale = 1 } = this.props

    const w = this.sprite.texture.orig.width * scale
    const h = this.sprite.texture.orig.height * scale

    const { 
      perspectivePath: path,
    } = props

    const corner1 = path[0]

    const corner2 = processPointOnLength({
      pointFrom: path[0],
      pointTo: path[1],
      length: w,
    })

    const corner4 = processPointOnLength({
      pointFrom: path[0],
      pointTo: path[3],
      length: h,
    })

    const pointOffset = [
      path[2][0] + corner4[0] - path[3][0],
      path[2][1] + corner4[1] - path[3][1],
    ]

    const corner3 = processPointOnLength({
      pointFrom: corner4,
      pointTo: pointOffset,
      length: w,
    })

    const next = [
      corner1,
      corner2,
      corner3,
      corner4,
    ]

    //console.log(`NEXT`, next)

    const quad = [
      new PIXI.Point(next[0][0], next[0][1]),
      new PIXI.Point(next[1][0], next[1][1]),
      new PIXI.Point(next[2][0], next[2][1]),
      new PIXI.Point(next[3][0], next[3][1]),
    ]

    this.sprite.tileProj.mapSprite(this.sprite, quad)
    //this.sprite.tileProj.mapBilinearSprite(this.sprite, quad)


    // this.sprite.scale.x = scale
    // this.sprite.scale.y = scale
  }

  update = (props) => {
    const { scale = 1 } = props

    this.updateMask(props)
    this.updatePerspective(props)
  }

  render() {
    return null
  }
}

export default (props) => {
  return (
    <Context.Consumer>
      {(context) => (
        <Texture {...props} context={ context } />
      )}
    </Context.Consumer>
  )
}