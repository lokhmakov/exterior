import React, { Component } from 'react'


import Context from 'evokeme/entity/all/Context'
import Provider from 'evokeme/entity/all/Provider'

import Line from 'pixi/web/Line'
import Texture from 'pixi/web/Texture'


const who = [`pixi`, `web`, `LineList`]

class GroupList extends Component {
  componentDidMount = () => {
    const { context } = this.props
    const { onMount } = this.props

    onMount && onMount({ context })
  }

  componentDidUpdate = () => {

  }

  onDragMove = ({ id, x, y }) => {
    const { context } = this.props

    context && context.item.update({ id, x, y })
  }

  onClick = ({ id, x, y }) => {
    const { onClick } = this.props

    onClick && onClick({ id, x, y })
  }

  selectGroupToPoint = ({ groupToPoint, id, point }) => {
    const pointIdList = []

    let index = -1
    let firstId = null
    while (index++ < groupToPoint.order.length - 1) {
      const lineToPointId = groupToPoint.order[index]
      const { lineId, pointId } = groupToPoint.data[lineToPointId]

      if (lineId === id) {
        if (!firstId) firstId = pointId
        pointIdList.push(pointId)
      }
    }

    if (firstId) pointIdList.push(firstId)

    if (!pointIdList.length) return null

    const path = pointIdList.map((id) => {
      const { x, y } = point.data[id]
      return [x, y]
    })

    return path
  }

  processKB = ({
    x1, y1,
    x2, y2,
  }) => {
    const k = - (y1 - y2) / (x2 - x1)
    const b = - (x1 * y2 - x2 * y1) / (x2 - x1)

    return { k, b }
  }

  processPointOnLength = ({ 
    pointFrom,
    pointTo,
    length: R,
  }) => {
    const [x1, y1] = pointFrom
    const [x2, y2] = pointTo

    const { k, b } = this.processKB({ x1, y1, x2, y2 })

    let x
    let y

    if (k !== Infinity) {
      x = (x1 < x2 ? 1 : -1) * Math.sqrt((R * R) / (1 + k * k)) + x1
      y = k * x + b
    } else {
      x = x1
      y = y1 + R
    }
    
    return [x, y]
  }

  renderLine({ id }) {
    const w = 1124
    const h = 802

    const { context } = this.props

    if (id !== `perspective`) return null

    const { point } = context
    const { groupToPoint } = context

    const path = this.selectGroupToPoint({
      groupToPoint,
      id,
      point,
    })

    const nextPoint = this.processPointOnLength({
      pointFrom: path[0],
      pointTo: path[1],
      length: w,
    })

    console.log(`nextDown`)

    const nextDown = this.processPointOnLength({
      pointFrom: path[0],
      pointTo: path[3],
      length: h,
    })

    //const

    const top = [
      path[0],
      nextPoint,
    ]

    const left = [
      path[0],
      nextDown,
    ]

    const pointDownRight = [
      path[2][0] + nextDown[0] - path[3][0],
      path[2][1] + nextDown[1] - path[3][1],
    ]

    const nextBottom = this.processPointOnLength({
      pointFrom: nextDown,
      pointTo: pointDownRight,
      length: w,
    })

    const bottom = [
      nextDown,
      nextBottom,
    ]

    const perspectivePath = [
      path[0],
      nextPoint,
      nextBottom,
      nextDown
    ]

    console.log(`perspectivePath`, JSON.stringify(perspectivePath))

    return [
      <Line key={ id + `1` } path={ top } />,
      <Line key={ id + `2` } path={ left } />,
      <Line key={ id + `3` } path={ bottom } />,
    ]
  }

  render() {
    const { context } = this.props

    if (context) {
      const { group, groupToPoint } = context

      return group.order.map((id) => {
        return this.renderLine({ id })
      })
    }

    return null
  }
}

export default (props) => {
  return (
    <Provider entity={[
      'groupToPoint',
      'group',
      'point',
    ]}>
      <Context.Consumer>
        {(context) => {
          return (
            <GroupList
              {...props}
              context={context}
            />
          )
        }}
      </Context.Consumer>
    </Provider>
  )
}